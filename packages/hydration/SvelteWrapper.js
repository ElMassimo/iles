/* eslint-disable no-cond-assign */
// const { component, slots, props } = $$props;
// </script>

// <svelte:component this={component} {...props}>
//   {#if slots.default}
//     {@html slots.default}
//   {/if}
// </svelte:component>

/* App.svelte generated by Svelte v3.43.2 */
import {
  HtmlTag,
  SvelteComponent,
  assign,
  check_outros,
  create_component,
  destroy_component,
  detach,
  empty,
  exclude_internal_props,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert,
  mount_component,
  noop,
  safe_not_equal,
  transition_in,
  transition_out,
} from 'svelte/internal'

function create_if_block (ctx) {
  let html_tag
  let raw_value = /* slots */ `${ctx[1].default}`
  let html_anchor

  return {
    c () {
      html_tag = new HtmlTag()
      html_anchor = empty()
      html_tag.a = html_anchor
    },
    m (target, anchor) {
      html_tag.m(raw_value, target, anchor)
      insert(target, html_anchor, anchor)
    },
    p: noop,
    d (detaching) {
      if (detaching) detach(html_anchor)
      if (detaching) html_tag.d()
    },
  }
}

// (5:0) <svelte:component this={component} {...props}>
function create_default_slot (ctx) {
  let if_block_anchor
  let if_block = /* slots */ ctx[1].default && create_if_block(ctx)

  return {
    c () {
      if (if_block) if_block.c()
      if_block_anchor = empty()
    },
    m (target, anchor) {
      if (if_block) if_block.m(target, anchor)
      insert(target, if_block_anchor, anchor)
    },
    p (ctx, dirty) {
      if (/* slots */ ctx[1].default) if_block.p(ctx, dirty)
    },
    d (detaching) {
      if (if_block) if_block.d(detaching)
      if (detaching) detach(if_block_anchor)
    },
  }
}

function create_fragment (ctx) {
  let switch_instance
  let switch_instance_anchor
  let current
  const switch_instance_spread_levels = [ctx[2]]
  let switch_value = /* component */ ctx[0]

  function switch_props (ctx) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx },
    }

    for (let i = 0; i < switch_instance_spread_levels.length; i += 1)
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i])

    return { props: switch_instance_props }
  }

  if (switch_value)
    switch_instance = new switch_value(switch_props(ctx))

  return {
    c () {
      if (switch_instance) create_component(switch_instance.$$.fragment)
      switch_instance_anchor = empty()
    },
    m (target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor)

      insert(target, switch_instance_anchor, anchor)
      current = true
    },
    p (ctx, [dirty]) {
      const switch_instance_changes = (dirty & /* props */ 4)
        ? get_spread_update(switch_instance_spread_levels, [get_spread_object(/* props */ ctx[2])])
        : {}

      if (dirty & /* $$scope */ 16)
        switch_instance_changes.$$scope = { dirty, ctx }

      if (switch_value !== (switch_value = /* component */ ctx[0])) {
        if (switch_instance) {
          group_outros()
          const old_component = switch_instance

          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1)
          })

          check_outros()
        }

        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx))
          create_component(switch_instance.$$.fragment)
          transition_in(switch_instance.$$.fragment, 1)
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor)
        }
        else {
          switch_instance = null
        }
      }
      else if (switch_value) {
        switch_instance.$set(switch_instance_changes)
      }
    },
    i (local) {
      if (current) return
      if (switch_instance) transition_in(switch_instance.$$.fragment, local)
      current = true
    },
    o (local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local)
      current = false
    },
    d (detaching) {
      if (detaching) detach(switch_instance_anchor)
      if (switch_instance) destroy_component(switch_instance, detaching)
    },
  }
}

function instance ($$self, $$props, $$invalidate) {
  const { component, slots, props } = $$props

  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)))
  }

  $$props = exclude_internal_props($$props)
  return [component, slots, props]
}

class App extends SvelteComponent {
  constructor (options) {
    super()
    init(this, options, instance, create_fragment, safe_not_equal, {})
  }
}

export default App
